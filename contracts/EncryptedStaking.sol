// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Encrypted ETH staking with time locks
/// @notice Stores stake amounts as encrypted values and finalizes withdrawals with on-chain decryption proofs.
contract EncryptedStaking is ZamaEthereumConfig {
    struct StakeInfo {
        euint64 encryptedAmount;
        uint64 unlockTime;
        bool withdrawn;
        bool exists;
        bytes32 pendingHandle;
    }

    mapping(address => StakeInfo) private _stakes;
    mapping(bytes32 => address) private _pendingWithdrawals;

    event Staked(address indexed user, bytes32 encryptedAmount, uint64 unlockTime);
    event WithdrawalRequested(address indexed user, bytes32 encryptedAmount);
    event WithdrawalFinalized(address indexed user, uint64 amount);

    /// @notice Stake ETH for a fixed duration. Amount is stored as an encrypted value.
    /// @param lockDuration Seconds the stake must remain locked.
    function stake(uint64 lockDuration) external payable {
        require(lockDuration > 0, "Lock duration is zero");
        require(msg.value > 0, "Stake amount is zero");
        require(msg.value <= type(uint64).max, "Stake too large");

        StakeInfo storage info = _stakes[msg.sender];
        require(info.withdrawn || info.unlockTime == 0, "Active stake in place");

        euint64 encryptedAmount = FHE.asEuint64(uint64(msg.value));

        info.encryptedAmount = encryptedAmount;
        info.unlockTime = uint64(block.timestamp + lockDuration);
        info.withdrawn = false;
        info.exists = true;
        info.pendingHandle = bytes32(0);

        FHE.allowThis(encryptedAmount);
        FHE.allow(encryptedAmount, msg.sender);

        emit Staked(msg.sender, FHE.toBytes32(encryptedAmount), info.unlockTime);
    }

    /// @notice Request a withdrawal once the lock period has expired.
    /// @dev Marks the encrypted amount as publicly decryptable so a decryption proof can be produced off-chain.
    function requestWithdrawal() external {
        StakeInfo storage info = _stakes[msg.sender];
        require(info.exists, "No stake");
        require(!info.withdrawn, "Already withdrawn");
        require(block.timestamp >= info.unlockTime, "Stake still locked");

        bytes32 handle = FHE.toBytes32(info.encryptedAmount);
        require(_pendingWithdrawals[handle] == address(0), "Request already open");

        info.pendingHandle = handle;
        _pendingWithdrawals[handle] = msg.sender;

        FHE.makePubliclyDecryptable(info.encryptedAmount);

        emit WithdrawalRequested(msg.sender, handle);
    }

    /// @notice Finalize a withdrawal using a decryption proof produced by the KMS.
    /// @param encryptedAmount The encrypted stake handle being withdrawn.
    /// @param clearAmount The clear-text amount obtained from the public decryption.
    /// @param decryptionProof Proof generated by the KMS to attest the decrypted value.
    function finalizeWithdrawal(euint64 encryptedAmount, uint64 clearAmount, bytes calldata decryptionProof) external {
        bytes32 handle = FHE.toBytes32(encryptedAmount);
        address staker = _pendingWithdrawals[handle];

        require(staker != address(0), "Unknown request");
        require(clearAmount > 0, "Invalid amount");

        StakeInfo storage info = _stakes[staker];
        require(!info.withdrawn, "Already withdrawn");
        require(block.timestamp >= info.unlockTime, "Stake still locked");
        require(handle == info.pendingHandle, "Handle mismatch");

        bytes32[] memory handlesList = new bytes32[](1);
        handlesList[0] = handle;

        bytes memory cleartexts = abi.encode(clearAmount);
        FHE.checkSignatures(handlesList, cleartexts, decryptionProof);

        info.withdrawn = true;
        info.pendingHandle = bytes32(0);
        delete _pendingWithdrawals[handle];

        (bool success, ) = staker.call{value: clearAmount}("");
        require(success, "ETH transfer failed");

        emit WithdrawalFinalized(staker, clearAmount);
    }

    /// @notice Returns the encrypted stake for a user.
    /// @dev View functions must not rely on msg.sender per repository requirements.
    function getEncryptedStake(address user) external view returns (euint64) {
        return _stakes[user].encryptedAmount;
    }

    /// @notice Returns the unlock time for a user stake.
    function getUnlockTime(address user) external view returns (uint64) {
        return _stakes[user].unlockTime;
    }

    /// @notice Indicates whether a user currently has an active stake.
    function hasStake(address user) external view returns (bool) {
        StakeInfo storage info = _stakes[user];
        return info.exists && !info.withdrawn;
    }

    /// @notice Returns the pending public decryption handle for a user if a withdrawal was requested.
    function getPendingHandle(address user) external view returns (bytes32) {
        return _stakes[user].pendingHandle;
    }

    /// @notice Indicates whether a user can request withdrawal based on the unlock timestamp.
    function isReadyForWithdrawal(address user) external view returns (bool) {
        StakeInfo storage info = _stakes[user];
        return info.exists && !info.withdrawn && block.timestamp >= info.unlockTime;
    }
}
